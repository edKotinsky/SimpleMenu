![PROJECT_PHOTO](https://github.com/edKotinsky/SimpleMenu/blob/master/proj_img.png)
#Меню на LCD дисплее
* [Описание](#chapter-0)
* [Функционал](#chapter-1)
* [Как ты можешь помочь](#chapter-2)
* [FAQ](#chapter-3)

<a id="chapter-0"></a>

Ru / Eng  will be soon

## Описание
Библиотека простого в обращении и легкого по использованию памяти меню SimpleMenu v 2.2
Cоветую использовать библиотеки [Алекса Гавера](https://alexgyver.ru/microlibs/), с ними весь код займет всего 15% ПЗУ и 7% ОЗУ.

Устройство меню жесткое: Главный экран -- Меню -- Пункт. Конечно, это накладывает ограничения, но в каких случаях необходима бОльшая гибкость? В большинстве проектов этого достаточно.

Меню управляется значениями от 1 до 4: ENTER, UP, DOWN и ESC, это могут быть кнопки или энкодер. 

В меню реализованы четыре вида пунктов, которые можно включить или отключить при компиляции: 

1. Пункт типа изменение значения **pTYPE_changeVal**. В этом пункте значение инкрементируется/декрементируется на 1 при нажатии на UP и DOWN соответственно.
2. Пункт типа выбор значения **pTYPE_selVal**, в нем значение задается выбором между двумя предустановленными вариантами
3. Пункт типа вызов функции **pTYPE_fuctionCall** позволяет пользователю подключить свою функцию
4. Пункт типа демонстрация значения **pTYPE_viewOnly** - в нем значение нельзя менять, можно только просматривать

Отключение типов пунктов при компиляции означает, что тип пункта использовать будет нельзя и код его реализации не будет занимать память на Ардуино.

Также пользователь сам определяет содержание главного экрана и название меню.

<a id="chapter-1"></a>
## Функционал
**Библиотека занимает EEPROM** с нулевого байта. Если нужно использовать EEPROM, используй EEMENU_nextFree, который вернет адрес следующего свободного байта после меню. 

	//массив пунктов содержит конфиги:
	//имя, тип пункта, мин, макс значение
	const menuStruct PROGMEM points [MENU_structNum] = {
		{"MENU v 2.2", 0, 0, 0},            //0			 нулевой элемент массива не пункт
		{"point1", pTYPE_setVal, 0, 10 },   //1			 нумерация пунктов начинается с 1
		{"point2", pTYPE_select, 0, 1},     //2
		{"point3", pTYPE_caller, 1, 2},     //3
		{"point4", pTYPE_view,   0, 0},     //4
		{"point5", pTYPE_view,   0, 0},     //5
		{"point6", pTYPE_view,   0, 0},     //6
	};

	//создание объекта меню и инициализация его массивом пунктов и объектом LCD экрана
	simpleMenu menu(points, LCD_object);

	//главная функция меню, должна крутиться в loop и принимать значение кнопки
	menu.control(button_value);

	//ты можешь задать свои значения для вывода на главный экран
	menu.mainDisplay("SimpleMenu v 2.2", "\r",
					 "display ", 1234);

	//так ты можешь использовать свою функцию
	menu.functionToCall(point_number, yourFunction);

	//значения для демонстрации в пункте pTYPE_viewOnly
	menu.showValue(point_number, 3.14);
	menu.showValue(point_number, "abc");
	menu.showValue(point_number, -123456);

	//как получить значение переменной пункта
	menu.getPointVal(point_number)
	//важно: значения возвращают только пункты типа pTYPE_changeVal и pTYPE_selVal

	//так можно отключить пункт - в него нельзя будет зайти, и напротив названия пункта появится значок
	menu.detachPoint(point_number);

	//так можно включить отключенный пункт
	menu.attachPoint(point_number);

## Настройки
Функционал меню определяется настройками, сделанными ПЕРЕД подключением библиотеки. 
Библиотеки Wire и LiquidCrystal также надо подключать до подключения SimpleMenu
	
	#define MENU_points 6					//количество пунктов (нумерация пунктов начинается с 1)
	#define MENU_sleepTime 10000			//сколько дисплей будет ждать, прежде чем уснет
	#define MENU_cleanTime 1000				//период очистки дисплея

	//подключение типов пунктов, если не задефайнить - этот тип пункта использовать будет нельзя
	#define MENU_pointType_SETVAL			//установка значения
	#define MENU_pointType_SELECT			//выбор
	#define MENU_pointType_FUNCTIONCALLER	//вызов функции
	#define MENU_pointType_VIEWONLY			//демонстрация

	//потом Wire и LiquidCrystal
	#include <Wire.h>
	#include <LiquidCrystal_I2C.h>

	//и в конце меню
	#include <SimpleMenu.h>

## Управление

**Если экран спит:**
нажатие на любую кнопку выводит его из сна, выводится главный экран.

**В Главном экране:**
нажатие на ENTER активирует Экран меню.

**В экране меню:**
пункты листаются кнопками UP и DOWN,
выход ESC,
вход в пункт, если можно войти ENTER,
напротив названия заблокированных пунктов выводится значок  , в них войти нельзя.

**В пункте:**
выход ESC, остальное зависит от типа пункта:

Пункт типа setVal:
изменение значения осуществляется кнопками UP и DOWN.

Пункт типа selectVal:
переключение выбранного значения циклично и осуществляется нажатием на любую кнопку кроме ESC.

В пункте типа viewOnly
значение менять нельзя.

Пункт типа functionCaller
выход ESC, остальное определяется пользовательской функцией.

<a id="chapter-2"></a>
## Как ты можешь помочь
Если нашел баг, создавай ветку или пиши mrkotofey@inbox.ru

<a id="chapter-2"></a>
## FAQ
Как устанавливать библиотеки и работать с Ардуино: https://support.arduino.cc/hc/en-us